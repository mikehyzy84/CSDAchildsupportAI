import fs from 'fs';

// Read the original SQL file
const sqlContent = fs.readFileSync('db/seed-sourcebook.sql', 'utf-8');

// Extract the header and document insert
const lines = sqlContent.split('\n');
let headerEndIndex = 0;
let documentInsertStart = 0;
let documentInsertEnd = 0;
let chunksStart = 0;

for (let i = 0; i < lines.length; i++) {
  if (lines[i].includes('-- Insert chunks')) {
    headerEndIndex = i - 1;
    documentInsertEnd = i - 1;
    chunksStart = i + 2; // Skip the comment and blank line
    break;
  }
  if (lines[i].includes('INSERT INTO documents')) {
    documentInsertStart = i;
  }
}

// Get header lines
const header = lines.slice(0, documentInsertStart).join('\n');

// Get document insert (modify to use ON CONFLICT)
const documentInsert = `-- Insert document record (using ON CONFLICT to allow multiple runs)
INSERT INTO documents (id, title, source, source_url, section, status, created_at, updated_at)
VALUES (
  '00000000-0000-0000-0000-000000000001'::uuid,
  '2024 CSDA Attorney Sourcebook',
  'CSDA Sourcebook',
  NULL,
  'Full Document',
  'completed',
  NOW(),
  NOW()
)
ON CONFLICT (id) DO NOTHING;

-- Insert chunks with search vectors (will be auto-generated by trigger)
`;

// Get all chunk inserts
const allChunks = lines.slice(chunksStart).join('\n');

// Split chunks into INSERT statements
const chunkStatements = [];
let currentStatement = [];
let inStatement = false;

for (let i = chunksStart; i < lines.length; i++) {
  const line = lines[i];

  if (line.trim().startsWith('INSERT INTO chunks')) {
    if (currentStatement.length > 0) {
      chunkStatements.push(currentStatement.join('\n'));
    }
    currentStatement = [line];
    inStatement = true;
  } else if (inStatement) {
    currentStatement.push(line);
    if (line.trim() === ');') {
      chunkStatements.push(currentStatement.join('\n'));
      currentStatement = [];
      inStatement = false;
    }
  }
}

console.log(`Total chunks found: ${chunkStatements.length}`);

// Split into 4 parts (roughly equal)
const chunksPerFile = Math.ceil(chunkStatements.length / 4);
console.log(`Chunks per file: ~${chunksPerFile}`);

const parts = [
  chunkStatements.slice(0, chunksPerFile),
  chunkStatements.slice(chunksPerFile, chunksPerFile * 2),
  chunkStatements.slice(chunksPerFile * 2, chunksPerFile * 3),
  chunkStatements.slice(chunksPerFile * 3)
];

// Write each part
parts.forEach((part, index) => {
  const partNum = index + 1;
  const filename = `db/seed-part${partNum}.sql`;

  const content = `${header}
-- Part ${partNum} of 4
-- Chunks: ${index * chunksPerFile} to ${Math.min((index + 1) * chunksPerFile - 1, chunkStatements.length - 1)}
-- Total chunks in this file: ${part.length}

${documentInsert}
${part.join('\n\n')}
`;

  fs.writeFileSync(filename, content);
  console.log(`Created ${filename} with ${part.length} chunks`);
});

console.log('\nâœ… Split complete! All 4 files are independently valid SQL.');
